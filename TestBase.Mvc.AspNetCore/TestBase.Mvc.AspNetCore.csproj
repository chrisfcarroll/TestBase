<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <RootNamespace>TestBase</RootNamespace>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyFileVersion>4.1.2.0</AssemblyFileVersion>
    <PackageVersion>4.1.2.0</PackageVersion>
    <Title>TestBase – Rich, fluent assertions and useful fakes for Mvc &amp; AdoNet.</Title>
<PackageDescription><![CDATA[*TestBase* gives you a flying start with 
- fluent assertions that are easy to extend
- explicit error messages
- tools to help you test with “heavyweight” dependencies on 
    - AspNetCore.Mvc, AspNet.Mvc or WebApi Contexts
	- HttpClient
	- Ado.Net
	- Streams & Logging

Chainable fluent assertions get you to the point concisely:
```
- ShouldEqualByValue() & ShouldEqualByValueExceptFor() 
  work with all kinds of object and collections, and 
  report what differed.
- string.ShouldMatch().ShouldEqualIgnoringCase(), ...
- numeric.ShouldBeBetween().ShouldEqualWithTolerance(), ...
- IEnumerable.ShouldAll().ShouldContain().ShouldNotContain(), ...
- Stream.ShouldHaveSameStreamContentAs(), Stream.ShouldContain()

UnitUnderTest.Action()
  .ShouldBeViewWithModel<TModel>()
  .Payload
    .ShouldEqualByValueExceptFor(new {Id=1, Payload1=expected}, ignoreFields)
    .Payload2
      .ShouldMatchIgnoringCase("I expected this");
```

TestBase.Mvc
------------

```
ControllerUnderTest.Action()
  .ShouldbeViewResult()
  .ShouldHaveModel<TModel>()
  .ShouldEqualByValue(expected)
ControllerUnderTest.Action()
  .ShouldBeRedirectToRouteResult()
  .ShouldHaveRouteValue("expectedKey", [Optional] "expectedValue");

ShouldHaveViewDataContaining(), ShouldBeJsonResult() etc.
```

TestBase.Mvc.AspNetCore
---------------------------------------------------------

- Test most controllers with zero setup using 
  `controllerUnderTest.WithControllerContext(actionUnderTest)`
- Test more complex controller/application dependencies using 
  `HostedMvcTestFixtureBase` and specify your MVCApplications `Startup` class.

```
[TestCase("/dummy")]
public async Task Put_Should_ReturnA(string url)
{
    var httpClient=GivenClientForRunningServer<Startup>();
    GivenRequestHeaders(httpClient, "CustomHeader", "HeaderValue1");

    var result = await httpClient.PutAsync(url, json);

    result.ShouldBe_202Accepted();
}
```

TestBase.Mvc for Mvc4 and Mvc 5
-------------------------------

Fake your http request &amp; context, and use the `RegisterRoutes` method 
of your actual application to setup `Controller.Url`

```
ControllerUnderTest
  .WithHttpContextAndRoutes(
    RouteConfig.RegisterRoutes, 
    "/incomingurl"
  );

ApiControllerUnderTest.WithWebApiHttpContext<T>(
    httpMethod, 
    requestUri,
    routeTemplate)
```

See also
 - TestBase
 - TestBase.HttpClient.Fake
 - TestBase.AdoNet
 - Serilog.Sinks.ListOfString 
 - Extensions.Logging.ListOfString]]></PackageDescription>
    <PackageReleaseNotes>ChangeLog
---------
4.1.2.0 TestBase.Mvc.AspNetCore provides WithControllerContext()
4.0.7.0 Added TestBase.FakeHttpClient. Added Should(predicate,...) as synonym of ShouldHave(predicate,...)
4.0.6.2 TestBase.Mvc can run controller actions on aspnetcore using controller.WithControllerContext()
4.0.5.2 TestBase.Mvc partially ported to netstandard20 / AspNetCore
4.0.4.1 StreamShoulds
4.0.3.0 StringListLogger as MS Logger and as Serilogger
4.0.1.0 Port to NetCore
3.0.3.0 Improves FakeDb setup
3.0.x.0 adds and/or corrects missing Shoulds()
2.0.5.0 adds some intellisense and FakeDbConnection.Verify(..., message,args) overload
</PackageReleaseNotes>
    <Copyright>(c) Chris F. Carroll, 2013-2018</Copyright>
    <Authors>Chris F Carroll</Authors>
    <Owners>Chris F Carroll</Owners>
    <PackageProjectUrl>http://github.com/chrisfcarroll/TestBase</PackageProjectUrl>
    <RepositoryUrl>http://github.com/chrisfcarroll/TestBase</RepositoryUrl>
    <RequireLicenseAcceptance>false</RequireLicenseAcceptance>
    <IncludeSymbols>true</IncludeSymbols>
    <PackageTags>nunit;test;unittest;tdd;fluent assertions;mock;mvc;aspnetmvc;aspnetcore;aspnetcoremvc</PackageTags>
</PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DefineConstants>TRACE;DEBUG;NETSTANDARD2_0;ASPNETCORE</DefineConstants>
  </PropertyGroup>

  <ItemGroup>
    <Compile Include="..\TestBase.Mvc\AssemblyInfo.cs" Link="AssemblyInfo.cs" />
    <Compile Include="..\TestBase.Mvc\DeSerializeExcludingFieldsContractResolver.cs" Link="DeSerializeExcludingFieldsContractResolver.cs" />
    <Compile Include="..\TestBase.Mvc\HostedMvcTestFixtureBase.cs" Link="HostedMvcTestFixtureBase.cs" />
    <Compile Include="..\TestBase.Mvc\MockApiHttpContextHelper.cs" Link="MockApiHttpContextHelper.cs" />
    <Compile Include="..\TestBase.Mvc\MockHttpContextHelperV3.cs" Link="MockHttpContextHelperV3.cs" />
    <Compile Include="..\TestBase.Mvc\MvcExtensions.cs" Link="MvcExtensions.cs" />
    <Compile Include="..\TestBase.Mvc\Shoulds\HttpResponseMessageShoulds.cs" Link="HttpResponseMessageShoulds.cs" />
    <Compile Include="..\TestBase.Mvc\Shoulds\MvcActionResultShoulds.cs" Link="MvcActionResultShoulds.cs" />
    <Compile Include="..\TestBase.Mvc\Shoulds\MvcFileResultShoulds.cs" Link="MvcFileResultShoulds.cs" />
    <Compile Include="..\TestBase.Mvc\Shoulds\MvcRouteResultShoulds.cs" Link="MvcRouteResultShoulds.cs" />
    <Compile Include="..\TestBase.Mvc\Shoulds\MvcViewResultShoulds.cs" Link="MvcViewResultShoulds.cs" />
    <Compile Include="..\TestBase.Mvc\TestableHttpListener.cs" Link="TestableHttpListener.cs" />
    <Compile Include="..\TestBase.Mvc\TypicalMvcRouteConfig.cs" Link="TypicalMvcRouteConfig.cs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore" Version="2.0.1" />
    <PackageReference Include="Microsoft.AspNetCore.Mvc" Version="2.0.2" />
    <PackageReference Include="Microsoft.AspNetCore.TestHost" Version="2.0.1" />
    <PackageReference Include="Moq" Version="4.8.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\TestBase\TestBase.csproj" />
  </ItemGroup>

</Project>
