<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <AssemblyVersion>4.1.2.7</AssemblyVersion>
    <AssemblyFileVersion>4.1.2.7</AssemblyFileVersion>
    <PackageVersion>4.1.2.7</PackageVersion>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <Title>TestBase – Rich, fluent assertions and tools for testing with heavyweight dependencies: AspNetCore, AdoNet, HttpClient, AspNet.Mvc, Streams, Logging</Title>
    <PackageDescription><![CDATA[*TestBase* gives you a flying start with 
- fluent assertions that are easy to extend
- sharp error messages
- tools to help you test with “heavyweight” dependencies on 
    - AspNet.Mvc or AspNetCore Contexts
	- HttpClient
	- Ado.Net
	- Streams & Logging

Mix & match with your favourite test runners & assertions. Chainable fluent assertions get you to the point concisely:
```
UnitUnderTest.Action()
  .ShouldNotBeNull()
  .ShouldEqualByValueExceptFor(new {Id=1, Descr=expected}, ignoreList )
  .Payload
    .ShouldMatchIgnoringCase("I expected this")
	.Should(someOtherPredicate);
	.Items
      .ShouldAll(predicate)
	  .ShouldContain(item)
	  .ShouldNotContain(predicate)
	  .Where(predicate)
	  .SingleOrAssertFail()

.ShouldEqualByValue().ShouldEqualByValueExceptFor(...) work with all kinds of object and collections, and report what differed.
string.ShouldMatch(pattern).ShouldNotMatch().ShouldBeEmpty().ShouldNotBeEmpty()
.ShouldNotBeNullOrEmptyOrWhiteSpace().ShouldEqualIgnoringCase()
.ShouldContain().ShouldStartWith().ShouldEndWith().ShouldBeContainedIn().ShouldBeOneOf().ShouldNotBeOneOf()…
numeric.ShouldBeBetween().ShouldEqualWithTolerance()....GreaterThan....LessThan...GreaterOrEqualTo ...
ienumerable.ShouldAll().ShouldContain().ShouldNotContain().ShouldBeEmpty().ShouldNotBeEmpty() ...
stream.ShouldHaveSameStreamContentAs().ShouldContain()
value.ShouldBe().ShouldNotBe().ShouldBeOfType().ShouldBeAssignableTo()...
```

See Also

TestBase.HttpClient.Fake
TestBase.AdoNet
TestBase.AspNetCore.Mvc
TestBase-Mvc for Mvc 3-5
Extensions.Logging.ListOfString
Serilog.Sinks.ListOfString

TestBase.HttpClient.Fake
------------------------

```
[Test]
public async Task Should_MatchTheRightExpectationAndReturnTheSetupResponse__GivenMultipleSetups()
{
  var httpClient = new FakeHttpClient()
    .Setup(x=>x.Method==HttpMethod.Put).Returns(new HttpResponseMessage(HttpStatusCode.Accepted))
    .Setup(x=>x.RequestUri.PathAndQuery.StartsWith("/this")).Returns(thisResponse)
    .Setup(x=>x.RequestUri.PathAndQuery.StartsWith("/that")).Returns(thatResponse)
    .Setup(x=>x.RequestUri.PathAndQuery.StartsWith("/forbidden")).Returns(new HttpResponseMessage(HttpStatusCode.Forbidden));

  (await httpClient.GetAsync("http://localhost/that")).ShouldEqualByValue(thatResponse);
  (await httpClient.GetAsync("http://localhost/forbidden")).StatusCode.ShouldBe(HttpStatusCode.Forbidden);

  httpClient.Verify(x=>x.Method==HttpMethod.Put);
  httClient.VerifyAll();     
}
```

TestBase.AdoNet
------------------
 
```
- fakeDbConnection.SetupForQuery(IEnumerable<TFakeData>; )
- fakeDbConnection.SetupForQuery(IEnumerable<Tuple<TFakeDataForTable1,TFakeDataForTable2>> )
- fakeDbConnection.SetupForQuery(fakeData, new[] {"FieldName1", FieldName2"})
- fakeDbConnection.SetupForExecuteNonQuery(rowsAffected)
- fakeDbConnection.ShouldHaveUpdated("tableName", [Optional] fieldList, whereClauseField)
- fakeDbConnection.ShouldHaveSelected("tableName", [Optional] fieldList, whereClauseField)
- fakeDbConnection.ShouldHaveUpdated("tableName", [Optional] fieldList, whereClauseField)
- fakeDbConnection.ShouldHaveDeleted("tableName", whereClauseField)
- fakeDbConnection.ShouldHaveInvoked(cmd => predicate(cmd))
- fakeDbConnection.ShouldHaveXXX().ShouldHaveParameter("name", value)
- fakeDbConnection.Verify(x=>x.CommandText.Matches("Insert [case] .*") && x.Parameters["id"].Value==1)
```

* `new RecordingDbConnection(IDbConnection)` helps you profile Ado.Net Db calls

TestBase.AspNetCore.Mvc & TestBase-Mvc
--------------------------------------

```
ControllerUnderTest.Action()
  .ShouldbeViewResult()
  .ShouldHaveModel<TModel>()
  .ShouldEqualByValue(expected)
ControllerUnderTest.Action()
  .ShouldBeRedirectToRouteResult()
  .ShouldHaveRouteValue("expectedKey", [Optional] "expectedValue");

ShouldHaveViewDataContaining(), ShouldBeJsonResult() etc.
```

Quickly test AspNetCore controllers with zero setup, even with Action dependencies on HttpContext, Request, Response, ViewData, UrlHelper using `controllerUnderTest.WithControllerContext()` :

```
[TestFixture]
public class WhenTestingControllersUsingFakeControllerContext
{
    [Test]
    public void ShouldBeViewWithModel_ShouldAssertViewResultAndNameAndModel_And_UrlHelper_ShouldWork()
    {
        var controllerUnderTest = 
            new AController()
                .WithControllerContext();

        var result= controllerUnderTest
                .Action("SomeController","SomeAction",other:1)
                .ShouldBeViewWithModel<AClass>("ViewName");
                    .FooterLink
                    .ShouldBe("/Controller/Action?other=1");
    }
}
```

... Or test against complex application dependencies using `HostedMvcTestFixtureBase` and specify your `Startup` class:

```
[TestFixture]
public class WhenTestingControllersUsingAspNetCoreTestTestServer : HostedMvcTestFixtureBase
{

    [TestCase("/dummy/action?id={id}")]
    public async Task Get_Should_ReturnActionResult(string url)
    {
        var id=Guid.NewGuid();
        var httpClient=GivenClientForRunningServer<Startup>();
        GivenRequestHeaders(httpClient, "CustomHeader", "HeaderValue1");
            
        var result= await httpClient.GetAsync(url.Formatz(new {id}));

        result
            .ShouldBe_200Ok()
            .Content.ReadAsStringAsync().Result
            .ShouldBe("Content");
    }

    [TestCase("/dummy")]
    public async Task Put_Should_ReturnA(string url)
    {
        var something= new Fixture().Create<Something>();
        var jsonBody= new StringContent(something.ToJSon(), Encoding.UTF8, "application/json");
        var httpClient=GivenClientForRunningServer<Startup>();
        GivenRequestHeaders(httpClient, "CustomHeader", "HeaderValue1");

        var result = await httpClient.PutAsync(url, jsonBody);

        result.ShouldBe_202Accepted();
        DummyController.Putted.ShouldEqualByValue( something );
    }
}
```

TestBase.Mvc for Mvc4 and Mvc 5
------------------
Use the `Controller.WithHttpContextAndRoutes()` extension methods to fake the 
http request &amp; context. And, by injecting the RegisterRoutes method of your
MvcApplication, you can use and test Controller.Url with your application's configured routes.

```
ControllerUnderTest
  .WithHttpContextAndRoutes(
    [Optional] Action&lt;RouteCollection&gt; mvcApplicationRoutesRegistration, 
    [optional] string requestUrl,
    [Optional] string query = "",
    [Optional] string appVirtualPath = "/",
    [Optional] HttpApplication applicationInstance)

ApiControllerUnderTest.WithWebApiHttpContext&lt;T&gt;(
    HttpMethod httpMethod, 
    [Optional] string requestUri,
    [Optional] string routeTemplate)
```


Testable Logging with ListOfString
--------------------------------------
`Extensions.Logging.ListOfString` for Microsoft.Extensions.Logging.Abstractions:
```
var logger= new LoggerFactory.AddProvider(new StringListLoggerProvider()).CreateLogger("Test1");
// of
var logLines = new StringListLogger();
var loggerFactory = new LoggerFactory().AddStringListLogger(logLines);
// or
var loggedLines = new List<string>();
var logger= new LoggerFactory().AddStringListLogger(loggedLines).CreateLogger("Test2");
 ... ;
StringListLogger.Instance
	.LoggedLines
	.ShouldContain(x=>x.Matches("kilroy was here"));
```
`Serilog.Sinks.ListOfString` for Serilog:
```
var loglines= new List<String>();
var logger=new LoggerConfiguration().WriteTo.StringList(loglines).CreateLogger();
... ;
logLines.ShouldContain(x=>x.Matches("kilroy was here"));
```

PDFs
----
`TestBase.Pdf.DocumentWithLineOfText(myLineOfText)` gives you a small but well-formed PDF document to play with.
(taken from https://www.cafe-encounter.net/p521/a-very-small-editable-pdf-for-testing)
]]></PackageDescription>
    <PackageReleaseNotes>ChangeLog
----------
4.1.2.7 Added item.ShouldBeOneOf / .ShouldNotBeOneOf      
4.1.2.6 Added String.ShouldContainEachOf()
4.1.2.5 Make Extensions.Logging.ListOfString Scopes public       
4.1.2.4 TestBase.AdoNet providers VerifyFirst(), VerifyLast(), VerifySingle(). Added ToCodeString() overload
4.1.2.1 Added TestBase.Pdf.DocumentWithLineOfText
4.1.2.0 TestBase.Mvc.AspNetCore provides WithControllerContext()
4.1.1.0 Should(assertion) and ShouldHave(assertion) as well as Should(predicate)
4.1.0.0 [ExpressionToCodeLib](https://www.nuget.org/packages/ExpressionToCodeLib/) and [FastExpressionCompiler](https://www.nuget.org/packages/FastExpressionCompiler/) ftw. Awesomer, and faster, assertions.
4.0.9.2  ShouldNotMatch(pattern)
4.0.9.1  ShouldNotContain( item or predicate)
4.0.9.0  Removed dependency on net4 version of Mono.Linq.Expressions
4.0.8.0  Separated Serilog.Sinks.ListOfString and Extensions.Logging.StringListLogger
4.0.7.0  Added TestBase.FakeHttpClient. Added Should(predicate,...) as synonym of ShouldHave(predicate,...)
4.0.6.2  TestBase.Mvc can run controller actions on aspnetcore using controller.WithControllerContext()
4.0.5.2  TestBase.Mvc partially ported to netstandard20 / AspNetCore
4.0.4.1  StreamShoulds
4.0.3.0  StringListLogger as MS Logger and as Serilogger
4.0.1.0  Port to NetCore
3.0.3.0  Improves FakeDb setup
3.0.x.0  adds and/or corrects missing Shoulds()
2.0.5.0  adds some intellisense and FakeDbConnection.Verify(..., message,args) overload
</PackageReleaseNotes>
    <Copyright>(c) Chris F. Carroll, 2013-2018</Copyright>
    <Authors>Chris F Carroll</Authors>
    <Owners>Chris F Carroll</Owners>
    <PackageProjectUrl>https://github.com/chrisfcarroll/TestBase</PackageProjectUrl>
    <RepositoryUrl>https://github.com/chrisfcarroll/TestBase</RepositoryUrl>
    <RequireLicenseAcceptance>false</RequireLicenseAcceptance>
    <IncludeSymbols>true</IncludeSymbols>
    <PackageTags>nunit;test;unittest;tdd;fluent assertions;mock;ado.net;mvc;aspnetmvc;aspnetcore;aspnetcoremvc</PackageTags>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <NoWarn>1701;1702;1705;NU1701</NoWarn>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <NoWarn>1701;1702;1705;NU1701</NoWarn>
  </PropertyGroup>
  <ItemGroup>
    <Compile Remove="TestLogger.cs" />
    <Compile Remove="WindsorExtensions.cs" />
    <Compile Remove="GivenMockEventStore.cs" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="ExpressionToCodeLib" Version="2.7.0" />
    <PackageReference Include="FastExpressionCompiler" Version="1.7.1" />
    <PackageReference Include="Newtonsoft.Json" Version="11.0.1" />
    <PackageReference Include="System.ComponentModel.Annotations" Version="4.4.1" />
  </ItemGroup>
</Project>